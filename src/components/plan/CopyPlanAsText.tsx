'use client';

import { useState } from 'react';
import { Check, FileText } from 'lucide-react';

interface PlanData {
  eventName: string;
  eventDate: string;
  people: {
    name: string;
    items: string[];
    status: 'confirmed' | 'pending' | 'declined';
    phone?: string;
    email?: string;
  }[];
}

interface Props {
  eventId: string;
}

export function CopyPlanAsText({ eventId }: Props) {
  const [copied, setCopied] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleCopy = async () => {
    setLoading(true);

    try {
      const res = await fetch(`/api/events/${eventId}/export-text`);
      if (!res.ok) throw new Error('Failed to export');

      const data: PlanData = await res.json();
      const text = formatPlanAsText(data);

      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (e) {
      console.error('Failed to copy:', e);
    } finally {
      setLoading(false);
    }
  };

  return (
    <button
      onClick={handleCopy}
      disabled={loading}
      className="flex items-center gap-2 px-3 py-2 text-sm border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 transition-colors"
    >
      {copied ? (
        <>
          <Check className="w-4 h-4 text-green-500" />
          <span className="text-green-600">Copied!</span>
        </>
      ) : (
        <>
          <FileText className="w-4 h-4" />
          <span>{loading ? 'Loading...' : 'Copy plan as text'}</span>
        </>
      )}
    </button>
  );
}

function formatPlanAsText(data: PlanData): string {
  const lines: string[] = [];

  lines.push(`${data.eventName}`);
  lines.push(`Date: ${data.eventDate}`);
  lines.push('');
  lines.push('─'.repeat(40));
  lines.push('');

  // Confirmed
  const confirmed = data.people.filter((p) => p.status === 'confirmed');
  if (confirmed.length > 0) {
    lines.push('✓ CONFIRMED:');
    confirmed.forEach((p) => {
      lines.push(`  ${p.name}: ${p.items.join(', ')}`);
    });
    lines.push('');
  }

  // Pending
  const pending = data.people.filter((p) => p.status === 'pending');
  if (pending.length > 0) {
    lines.push('⏳ WAITING FOR RESPONSE:');
    pending.forEach((p) => {
      const contact = p.phone || p.email || '';
      lines.push(`  ${p.name}: ${p.items.join(', ')}${contact ? ` — ${contact}` : ''}`);
    });
    lines.push('');
  }

  // Declined
  const declined = data.people.filter((p) => p.status === 'declined');
  if (declined.length > 0) {
    lines.push('❌ DECLINED (needs reassignment):');
    declined.forEach((p) => {
      lines.push(`  ${p.name}: ${p.items.join(', ')}`);
    });
    lines.push('');
  }

  lines.push('─'.repeat(40));
  lines.push(`Generated by Gather — ${new Date().toLocaleString()}`);

  return lines.join('\n');
}
